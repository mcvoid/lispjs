{"name":"Lispjs","tagline":"A lisp interpreter in JavaScript","body":"# lispjs\r\n\r\nLispjs is a simple lisp interpreter designed for experimental purposes.\r\n\r\n## Features\r\n* A reader, printer, and evaluator\r\n* Supports numbers, symbols, booleans\r\n* Lexical scoping\r\n* Function literals, and simple macros (functions which don't `eval` their arguments first)\r\n* Supports recursion, even in anonymous functions\r\n* list operations (`list`, `cons`, `concat`, `first`, `rest`)\r\n* Higher-order functions (`map`, `reduce`, `apply`)\r\n* An environment that can be customized with javascript\r\n* Clojure-ish syntax for easier typing\r\n* `eval` keyword (take that, ClojureScript!)\r\n* Extremely simple implementation\r\n\r\n## Usage\r\n```\r\nrequire(\"src/lisp\", function(lisp) {\r\n  var code = \"((fn (n) (if (zero? n) 1 (* n (recur (-- n))))) 4)\";\r\n  var form = lisp.read(code);\r\n  var result = lisp.eval(form);\r\n  console.log(lisp.print(result));\r\n});\r\n```\r\nOr...\r\n```\r\nrequire(\"src/lisp\", function(lisp) {\r\n  var a = lisp.interpret(\"((fn (n) (if (zero? n) 1 (* n (recur (-- n))))) 4)\");\r\n  console.log(a);\r\n});\r\n```\r\n\r\n## What it doesn't support (yet)\r\n* Because I need a better lexer\r\n  * Strings\r\n  * Maps\r\n  * short quoting (using `'`)\r\n  * treating commas as whitespace\r\n* Because I need a better evaluator\r\n  * Tail recursion (need a trampoline mechanism built-in)\r\n  * `loop` (clojure-like iteration)\r\n* Because it's low on my priority queue\r\n  * `set!` (right now `def` can rewrite any binding in the current environment)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}